# SPDX-License-Identifier: GPL-2.0+
# Copyright (c) Alper Nebi Yasak <alpernebiyasak@gmail.com>

# Based on existing binman code:
# Copyright (c) 2018 Google, Inc
# Written by Simon Glass <sjg@chromium.org>

# Support for a Chromium OS verified boot kernel partition.

from collections import defaultdict, OrderedDict
import os

from binman.entry import Entry, EntryArg

from dtoc import fdt_util
from patman import tools

class Entry_depthcharge_kernel(Entry):
    """An entry which contains a Chromium OS verified boot kernel partition

    For example:

        binman {
            depthcharge-kernel {
                keydir = "/usr/share/vboot/devkeys";
                keyblock = "kernel.keyblock";
                signprivate = "kernel_data_key.vbprivk";
                version = <1>;
                preamble-flags = <0>;
                arch = "arm";

                vmlinuz {
                    u-boot {
                    };
                };

                config {
                    text {
                        text = "";
                    };
                };

                bootloader {
                    text {
                        text = "";
                    };
                };
            };
        };

    Properties / Entry arguments:
        - keydir: Directory containing the public keys to use
        - keyblock: Name of the key file to use (inside keydir)
        - signprivate: Name of provide key file to use (inside keydir)
        - version: Version number of the vblock (typically 1)
        - arch: Cpu architecture (one of x86|amd64, arm|aarch64, mips)

    Optional properties / arguments:
        - preamble-flags: Value of the vboot preamble flags (typically 0)
        - kloadaddr: RAM address to load the kernel body (optional)
        - pad: Vblock padding size (optional)

    Image subsections:
        - vmlinuz: The kernel to sign and pack (typically a FIT image
          on arm architectures)
        - config: The kernel commandline file, up to 4096 bytes. If not
          given, an empty file is used.
        - bootloader: "Bootloader stub". If not given, an empty file is
          used.

    Output files:
        - <unique_name>.vmlinuz - input vmlinuz file passed to futility
        - <unique_name>.config - input config file passed to futility
        - <unique_name>.booloader - input bootloader file passed to futility
        - <unique_name>.kpart - output file generated by futility (which is
            used as the entry contents)

    Chromium OS packs and signs the kernel, config and bootloader into a
    custom format and writes it to a GPT partition. This allows depthcharge to
    verify that the kernel and its parameters are genuine before booting it.
    """
    def __init__(self, section, etype, node):
        super().__init__(section, etype, node)
        (self.keydir, self.keyblock, self.signprivate, self.version,
         self.preamble_flags, self.arch, self.kloadaddr, self.vblock_pad,
        ) = self.GetEntryArgsOrProps([
            EntryArg('keydir', str),
            EntryArg('keyblock', str),
            EntryArg('signprivate', str),
            EntryArg('version', int),
            EntryArg('preamble-flags', int),
            EntryArg('arch', str),
            EntryArg('kloadaddr', int),
            EntryArg('vblock-pad', int),
        ])
        self._entries = defaultdict(list)

    def ReadNode(self):
        self._ReadSubnodes()
        super().ReadNode()

    def _ReadSubnodes(self):
        for node in self._node.subnodes:
            if node.name in ('vmlinuz', 'config', 'bootloader'):
                for subnode in node.subnodes:
                    entry = Entry.Create(self.section, subnode)
                    entry.ReadNode()
                    self._entries[node.name].append(entry)
            else:
                self._Raise("Can't have a %s subsection" % node.name)
        if 'vmlinuz' not in self._entries:
            self._Raise("Must have a vmlinuz subsection")

    def _BuildEntries(self, section):
        offset = 0
        data = b''
        for entry in self._entries[section]:
            if not entry.ObtainContents():
                return None
            offset = entry.Pack(offset)
            pad = entry.offset - len(data) + entry.pad_before
            if pad > 0:
                data += tools.GetBytes(pad_byte, pad)
            data += entry.GetData()
            pad = entry.offset + entry.size - len(data)
            if pad > 0:
                data += tools.GetBytes(pad_byte, pad)

        return data

    def ObtainContents(self):
        uniq = self.GetUniqueName()
        vmlinuz_fname = tools.GetOutputFilename('%s.vmlinuz' % uniq)
        config_fname = tools.GetOutputFilename('%s.config' % uniq)
        bootloader_fname = tools.GetOutputFilename('%s.bootloader' % uniq)

        vmlinuz_data = self._BuildEntries('vmlinuz')
        if vmlinuz_data is None:
            return False

        config_data = self._BuildEntries('config')
        if config_data is None:
            return False
        elif config_data == b'':
            config_data = tools.GetBytes(0, 512)

        bootloader_data = self._BuildEntries('config')
        if bootloader_data is None:
            return False
        elif bootloader_data == b'':
            bootloader_data = tools.GetBytes(0, 512)

        tools.WriteFile(vmlinuz_fname, vmlinuz_data)
        tools.WriteFile(config_fname, config_data)
        tools.WriteFile(bootloader_fname, bootloader_data)

        output_fname = tools.GetOutputFilename('%s.kpart' % uniq)
        prefix = self.keydir + '/'
        args = [
            'vbutil_kernel',
            '--pack', output_fname,
            '--keyblock', prefix + self.keyblock,
            '--signprivate', prefix + self.signprivate,
            '--version', '%d' % self.version,
            '--vmlinuz', vmlinuz_fname,
            '--bootloader', bootloader_fname,
            '--config', config_fname,
            '--arch', self.arch,
        ]
        if self.preamble_flags is not None:
            '--flags', '%d' % self.preamble_flags,
        if self.kloadaddr is not None:
            args += ['--kloadaddr', '%d' % self.kloadaddr]
        if self.vblock_pad is not None:
            args += ['--pad', '%d' % self.vblock_pad]
        stdout = tools.Run('futility', *args)

        self.SetContents(tools.ReadFile(output_fname))
        return True
